# -*- coding: ascii -*-
"""End-to-end test for QA JSON integration with CLI and report generation."""

import unittest
import tempfile
import os
import json
import shutil
from unittest.mock import patch
import pandas as pd

from src.halogenator.cli import cmd_enum, cmd_report
from src.halogenator.io_utils import write_smi


class TestQAJsonE2E(unittest.TestCase):
    """Test that QA JSON is generated by CLI and consumed by report."""
    
    def setUp(self):
        """Set up test environment with temp directory and test data."""
        self.test_dir = tempfile.mkdtemp()
        self.config = {
            'io': {
                'smiles_file': os.path.join(self.test_dir, 'parents.smi'),
                'products_table': os.path.join(self.test_dir, 'products.parquet')
            },
            'halogens': ['F', 'Cl'],
            'k_max': 1,
            'constraints': {'per_ring_quota': 2, 'min_graph_distance': 2},
            'standardize': {'do_tautomer': False},
            'qc': {'sanitize_strict': True},
            'pruning': {'enable_symmetry_fold': True}
        }
        
        # Create test parent molecules file
        test_parents = [
            ('c1ccccc1', 'benzene'),
            ('c1ccc(O)cc1', 'phenol'),
            ('O=c1c(O)c(-c2ccc(O)c(O)c2)oc2cc(O)cc(O)c12', 'quercetin')
        ]
        write_smi(test_parents, self.config['io']['smiles_file'])
    
    def tearDown(self):
        """Clean up test directory."""
        shutil.rmtree(self.test_dir, ignore_errors=True)
    
    def test_cli_enum_generates_qa_json(self):
        """Test that cmd_enum generates QA JSON file."""
        # Mock args object
        class MockArgs:
            def __init__(self, outdir):
                self.k = 1
                self.subset = 'flavonoids'
                self.outdir = outdir
        
        args = MockArgs(self.test_dir)
        
        # Run enumeration
        with patch('builtins.print'):  # Suppress output for cleaner test
            cmd_enum(self.config, args)
        
        # Check that QA JSON was generated
        qa_json_path = os.path.join(self.test_dir, 'qa_summary.json')
        self.assertTrue(os.path.exists(qa_json_path), f"QA JSON not found at {qa_json_path}")
        
        # Verify JSON structure
        with open(qa_json_path, 'r') as f:
            qa_data = json.load(f)
        
        self.assertIn('total', qa_data)
        self.assertIn('metadata', qa_data)
        
        total_stats = qa_data['total']
        self.assertIn('isotope_unavailable', total_stats)
        self.assertIn('isotope_miss', total_stats)
        self.assertIn('atommap_used', total_stats)
        self.assertIn('heuristic_used', total_stats)
        self.assertIn('no_product_matches', total_stats)
        self.assertIn('template_unsupported', total_stats)
        self.assertIn('qa_paths', total_stats)
        
        # QA stats should be non-negative integers
        for key, value in total_stats.items():
            if key != 'qa_paths':
                self.assertIsInstance(value, int)
                self.assertGreaterEqual(value, 0)
        
        # qa_paths should be a dictionary
        self.assertIsInstance(total_stats['qa_paths'], dict)
    
    def test_report_reads_qa_json_and_includes_in_csv(self):
        """Test that report generation reads QA JSON and includes metrics in CSV."""
        # First run enumeration to generate products and QA JSON
        class MockEnumArgs:
            def __init__(self, outdir):
                self.k = 1
                self.subset = 'flavonoids'
                self.outdir = outdir
        
        enum_args = MockEnumArgs(self.test_dir)
        
        with patch('builtins.print'):
            cmd_enum(self.config, enum_args)
        
        # Verify products and QA JSON exist
        products_path = self.config['io']['products_table']
        qa_json_path = os.path.join(self.test_dir, 'qa_summary.json')
        
        self.assertTrue(os.path.exists(products_path))
        self.assertTrue(os.path.exists(qa_json_path))
        
        # Now run report generation
        report_config = {
            'io': {
                'products_table': products_path,
                'smiles_file': self.config['io']['smiles_file'],
                'summary_csv': os.path.join(self.test_dir, 'summary.csv'),
                'summary_pivot_csv': os.path.join(self.test_dir, 'summary_pivot.csv')
            },
            'k_max': 1
        }
        
        class MockReportArgs:
            def __init__(self, outdir):
                self.subset = 'flavonoids'
                self.outdir = outdir
        
        report_args = MockReportArgs(self.test_dir)
        
        with patch('builtins.print'):
            cmd_report(report_config, report_args)
        
        # Check that summary CSV was generated
        summary_path = report_config['io']['summary_csv']
        self.assertTrue(os.path.exists(summary_path))
        
        # Read and verify CSV contains QA metrics
        df = pd.read_csv(summary_path)
        
        # Look for QA metrics in the CSV
        qa_metric_keywords = ['Isotope unavailable', 'Isotope miss', 'AtomMap used', 
                             'Heuristic used', 'No-product matches', 'Template unsupported']
        diagnostics_rows = df[df['Metric'].str.contains('|'.join(qa_metric_keywords), na=False)]
        self.assertGreater(len(diagnostics_rows), 0, "No QA diagnostics found in summary CSV")
        
        # Check for specific QA metrics
        qa_metrics = set(diagnostics_rows['Metric'].tolist())
        expected_metrics = {
            'Isotope unavailable (attempts)', 
            'Isotope miss (matches)',
            'AtomMap used (attempts)',
            'Heuristic used (attempts)',
            'No-product matches',
            'Template unsupported (attempts)'
        }
        
        for metric in expected_metrics:
            self.assertIn(metric, qa_metrics, f"Missing QA metric: {metric}")
            # Get the value for this metric
            metric_row = diagnostics_rows[diagnostics_rows['Metric'] == metric]
            self.assertEqual(len(metric_row), 1, f"Should have exactly one row for {metric}")
            value = metric_row['Value'].iloc[0]
            self.assertIsInstance(int(value), int, f"QA metric {metric} should be integer")
            self.assertGreaterEqual(int(value), 0, f"QA metric {metric} should be non-negative")
    
    def test_qa_json_structure_matches_expected_schema(self):
        """Test that generated QA JSON has expected structure."""
        class MockArgs:
            def __init__(self, outdir):
                self.k = 1
                self.subset = 'flavonoids'
                self.outdir = outdir
        
        args = MockArgs(self.test_dir)
        
        with patch('builtins.print'):
            cmd_enum(self.config, args)
        
        qa_json_path = os.path.join(self.test_dir, 'qa_summary.json')
        with open(qa_json_path, 'r') as f:
            qa_data = json.load(f)
        
        # Verify top-level structure
        self.assertEqual(set(qa_data.keys()), {'total', 'metadata'})
        
        # Verify metadata
        metadata = qa_data['metadata']
        self.assertIn('description', metadata)
        self.assertIn('semantics', metadata)
        
        # Verify total stats structure
        total = qa_data['total']
        required_keys = {
            'no_product_matches', 'template_unsupported',
            'dedup_hits_statesig', 'dedup_hits_inchi',
            'qa_paths'
        }
        self.assertEqual(set(total.keys()), required_keys)
        
        # Verify qa_paths is properly structured
        qa_paths = total['qa_paths']
        self.assertIsInstance(qa_paths, dict)
        
        # All values should be non-negative integers
        for path, count in qa_paths.items():
            self.assertIsInstance(path, str)
            self.assertIsInstance(count, int)
            self.assertGreaterEqual(count, 0)
    
    def test_no_products_still_generates_qa_json(self):
        """Test that QA JSON is generated even when no products are created."""
        # Create a config that likely produces no products (very restrictive)
        restrictive_config = self.config.copy()
        restrictive_config['constraints'] = {'per_ring_quota': 0, 'min_graph_distance': 10}
        
        # Use only benzene which is less likely to produce halogenated products
        benzene_only = [('c1ccccc1', 'benzene')]
        benzene_file = os.path.join(self.test_dir, 'benzene_only.smi')
        write_smi(benzene_only, benzene_file)
        restrictive_config['io']['smiles_file'] = benzene_file
        
        class MockArgs:
            def __init__(self, outdir):
                self.k = 1
                self.subset = 'flavonoids'
                self.outdir = outdir
        
        args = MockArgs(self.test_dir)
        
        with patch('builtins.print'):
            cmd_enum(restrictive_config, args)
        
        # QA JSON should still exist
        qa_json_path = os.path.join(self.test_dir, 'qa_summary.json')
        self.assertTrue(os.path.exists(qa_json_path))
        
        # Verify structure is still valid
        with open(qa_json_path, 'r') as f:
            qa_data = json.load(f)
        
        self.assertIn('total', qa_data)
        self.assertIn('metadata', qa_data)
        
        total_stats = qa_data['total']
        # Should have some attempts even if no products
        total_attempts = sum(total_stats.get('qa_paths', {}).values())
        # Note: We expect at least some attempts were made
        self.assertGreaterEqual(total_attempts, 0)


if __name__ == '__main__':
    unittest.main()